rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE PHILOSOPHY
     * This ruleset implements a robust, role-based access control (RBAC) model tailored for a media production 
     * environment. It prioritizes "Authorization Independence" by leveraging denormalized data (like member 
     * ID arrays) directly on documents to ensure high-performance security checks without excessive 
     * cross-document lookups.
     * 
     * DATA STRUCTURE
     * The hierarchy is split between top-level administrative collections (Clients, Invoices, TeamMembers) 
     * and a nested project hierarchy (Projects -> Tasks -> TimeEntries). 
     * 
     * KEY SECURITY DECISIONS
     * 1. RBAC via Collection Existence: Roles are determined by the presence of a user's UID in specific 
     *    role-based collections (e.g., /roles_admin/{uid}).
     * 2. Membership-Based Access: Projects and their sub-resources are secured by checking if the 
     *    authenticated user's UID is present in a `teamMemberIds` or `projectTeamMemberIds` list.
     * 3. Denormalization for Performance: Critical authorization fields (like project membership) are 
     *    duplicated from parent projects into tasks and time entries to allow for fast, direct rule evaluation.
     * 4. Prototyping Flexibility: While authorization is strictly enforced based on roles and ownership, 
     *    the specific schema of content fields is not validated to allow for rapid frontend iteration.
     */

    // --- Global Helper Functions ---

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Role Checks based on the "Existence over Content" principle defined in the IR
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isProjectManager() {
      return isSignedIn() && (isAdmin() || exists(/databases/$(database)/documents/roles_projectManager/$(request.auth.uid)));
    }

    function isSales() {
      return isSignedIn() && (isAdmin() || exists(/databases/$(database)/documents/roles_sales/$(request.auth.uid)));
    }

    function isBilling() {
      return isSignedIn() && (isAdmin() || exists(/databases/$(database)/documents/roles_billing/$(request.auth.uid)));
    }

    // --- Collection Rules ---

    /**
     * @description Rules for Role definitions. Only Admins can manage the global roles.
     * @path /roles/{roleId}
     * @allow (get) Any signed-in user to see available roles.
     * @deny (write) Non-admins from modifying system roles.
     * @principle Administrative lockdown for system configuration.
     */
    match /roles/{roleId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Role Assignment Collections (existence-based RBAC).
     * @path /roles_{roleName}/{userId}
     * @principle Internal role lookups.
     */
    match /roles_admin/{uid} { allow read: if isSignedIn(); allow write: if isAdmin(); }
    match /roles_projectManager/{uid} { allow read: if isSignedIn(); allow write: if isAdmin(); }
    match /roles_sales/{uid} { allow read: if isSignedIn(); allow write: if isAdmin(); }
    match /roles_billing/{uid} { allow read: if isSignedIn(); allow write: if isAdmin(); }

    /**
     * @description Client records for CRM. Accessed by Admin, Project Managers, and Sales.
     * @path /clients/{clientId}
     * @allow (create) if the user has Admin, PM, or Sales roles.
     * @deny (delete) if the user is not an Admin.
     * @principle Role-based access for business-critical data.
     */
    match /clients/{clientId} {
      allow get: if isProjectManager() || isSales() || isBilling();
      allow list: if isProjectManager() || isSales() || isBilling();
      allow create, update: if isProjectManager() || isSales();
      allow delete: if isAdmin();
    }

    /**
     * @description Team Member profiles. Users can manage themselves; Admins manage everyone.
     * @path /teamMembers/{teamMemberId}
     * @allow (update) if request.auth.uid matches the document ID.
     * @deny (create) if creating a profile for a different UID.
     * @principle Path-based ownership combined with global admin overrides.
     */
    match /teamMembers/{teamMemberId} {
      allow get: if isSignedIn();
      allow list: if isAdmin() || isProjectManager();
      allow create: if isOwner(teamMemberId) || isAdmin();
      allow update: if (resource != null && isOwner(teamMemberId)) || isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Project management. Access is restricted to assigned team members or high-level roles.
     * @path /projects/{projectId}
     * @allow (list) if user is in the teamMemberIds array.
     * @deny (write) if user is not an Admin or Project Manager.
     * @principle Membership-based shared access.
     */
    match /projects/{projectId} {
      function isProjectMember() {
        return request.auth.uid in resource.data.teamMemberIds;
      }
      allow get, list: if isProjectManager() || isProjectMember() || isBilling();
      allow create, update: if isProjectManager();
      allow delete: if isAdmin();
    }

    /**
     * @description Tasks within a project. Uses denormalized project membership for authorization.
     * @path /projects/{projectId}/tasks/{taskId}
     * @allow (get) if user is in projectTeamMemberIds or the specific assignee.
     * @principle Authorization independence via denormalization.
     */
    match /projects/{projectId}/tasks/{taskId} {
      function isAssigned() {
        return resource.data.assignedTeamMemberId == request.auth.uid;
      }
      function inProject() {
        return request.auth.uid in resource.data.projectTeamMemberIds;
      }
      allow get, list: if isProjectManager() || inProject() || isAssigned();
      allow create, update: if isProjectManager() || inProject();
      allow delete: if isProjectManager();
    }

    /**
     * @description Time tracking entries. Securely allows creators to manage their own logs.
     * @path /projects/{projectId}/tasks/{taskId}/timeEntries/{timeEntryId}
     * @allow (create) if creatorId matches auth.uid and consistency is maintained.
     * @principle Creator ownership and relational integrity.
     */
    match /projects/{projectId}/tasks/{taskId}/timeEntries/{timeEntryId} {
      function isCreator() {
        return resource.data.teamMemberId == request.auth.uid;
      }
      allow get, list: if isProjectManager() || isCreator();
      allow create: if isSignedIn() && request.resource.data.teamMemberId == request.auth.uid;
      allow update: if resource != null && (isCreator() || isProjectManager());
      allow delete: if resource != null && (isCreator() || isProjectManager());
    }

    /**
     * @description Financial invoices. Restricted to Admin and Billing roles.
     * @path /invoices/{invoiceId}
     * @allow (read/write) for users with Billing or Admin roles.
     * @principle Functional segregation of financial data.
     */
    match /invoices/{invoiceId} {
      allow read, write: if isBilling();
    }

    /**
     * @description Detailed line items for invoices.
     * @path /invoices/{invoiceId}/lineItems/{lineItemId}
     * @principle Inherited billing role access.
     */
    match /invoices/{invoiceId}/lineItems/{lineItemId} {
      allow read, write: if isBilling();
    }

    /**
     * @description Sales pipeline opportunities.
     * @path /opportunities/{opportunityId}
     * @allow (update) if the user is the assigned sales person.
     * @principle Role-based assignment and ownership.
     */
    match /opportunities/{opportunityId} {
      function isAssignedSales() {
        return resource.data.assignedTeamMemberId == request.auth.uid;
      }
      allow get, list: if isSales() || isAssignedSales();
      allow create, update: if isSales();
      allow delete: if isAdmin();
    }

    /**
     * @description Global company billing settings (Singleton).
     * @path /companyBillingSettings/{settingsId}
     * @allow (read) by Billing role and Admins.
     * @allow (write) strictly by Admins.
     * @principle Singleton configuration protection.
     */
    match /companyBillingSettings/{settingsId} {
      allow get: if isBilling();
      allow list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }
  }
}